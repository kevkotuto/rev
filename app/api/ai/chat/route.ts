import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth"
import { authOptions } from "@/lib/auth"
import { ChatOpenAI } from "@langchain/openai"
import { AgentExecutor, createOpenAIFunctionsAgent } from "langchain/agents"
import { ChatPromptTemplate } from "@langchain/core/prompts"
import { HumanMessage, AIMessage } from "@langchain/core/messages"
import { DynamicStructuredTool } from "@langchain/core/tools"
import { z } from "zod"
import { prisma } from "@/lib/prisma"

// Configuration du mod√®le IA
const llm = new ChatOpenAI({
  model: "gpt-4o-mini",
  temperature: 0.7,
  openAIApiKey: process.env.OPENAI_API_KEY,
})

// Outils personnalis√©s pour REV
const createTaskTool = new DynamicStructuredTool({
  name: "create_task",
  description: "Cr√©er une nouvelle t√¢che pour l'utilisateur",
  schema: z.object({
    title: z.string().describe("Titre de la t√¢che"),
    description: z.string().optional().describe("Description d√©taill√©e"),
    priority: z.enum(["LOW", "MEDIUM", "HIGH", "URGENT"]).default("MEDIUM"),
    dueDate: z.string().optional().describe("Date d'√©ch√©ance (YYYY-MM-DD)"),
    projectId: z.string().optional().describe("ID du projet associ√©"),
  }),
  func: async ({ title, description, priority, dueDate, projectId }, runManager, userId) => {
    try {
      const taskData: any = {
        title,
        description,
        priority,
        status: "TODO",
        userId: userId as string,
        dueDate: dueDate ? new Date(dueDate) : null,
      }

      if (projectId) {
        taskData.projectId = projectId
      }

      const task = await prisma.task.create({
        data: taskData,
        include: {
          project: { select: { name: true } }
        }
      })

      return `‚úÖ T√¢che cr√©√©e avec succ√®s: "${title}" (Priorit√©: ${priority})`
    } catch (error) {
      return `‚ùå Erreur lors de la cr√©ation de la t√¢che: ${error}`
    }
  },
})

const getProjectsTool = new DynamicStructuredTool({
  name: "get_projects",
  description: "R√©cup√©rer la liste des projets de l'utilisateur avec possibilit√© de recherche par nom",
  schema: z.object({
    limit: z.number().optional().default(10).describe("Nombre maximum de projets √† retourner"),
    status: z.string().optional().describe("Filtrer par statut (IN_PROGRESS, COMPLETED, etc.)"),
    searchName: z.string().optional().describe("Rechercher un projet par nom (recherche insensible √† la casse)"),
  }),
  func: async ({ limit, status, searchName }, runManager, userId) => {
    try {
      const where: any = { userId: userId as string }
      if (status) where.status = status
      if (searchName) {
        where.name = {
          contains: searchName,
          mode: 'insensitive'
        }
      }

      const projects = await prisma.project.findMany({
        where,
        take: limit,
        include: {
          client: { select: { name: true } },
          _count: { select: { tasks: true } }
        },
        orderBy: { updatedAt: 'desc' }
      })

      if (projects.length === 0) {
        if (searchName) {
          // Si aucun projet trouv√© avec le nom recherch√©, chercher tous les projets
          const allProjects = await prisma.project.findMany({
            where: { userId: userId as string },
            take: 5,
            include: {
              client: { select: { name: true } },
              _count: { select: { tasks: true } }
            },
            orderBy: { updatedAt: 'desc' }
          })
          
          if (allProjects.length === 0) {
            return `‚ùå Aucun projet trouv√© avec le nom "${searchName}" et vous n'avez aucun projet existant. Voulez-vous que je cr√©e le projet "${searchName}" pour vous ?`
          }
          
          const projectNames = allProjects.map(p => `- ${p.name}`).join('\n')
          return `‚ùå Aucun projet trouv√© avec le nom "${searchName}". Voici vos projets existants :\n\n${projectNames}\n\nVoulez-vous que je cr√©e le projet "${searchName}" ou souhaitez-vous travailler avec un projet existant ?`
        }
        return "‚ùå Aucun projet trouv√©. Vous pouvez cr√©er un nouveau projet si vous le souhaitez."
      }

      const projectList = projects.map(p => ({
        id: p.id,
        name: p.name,
        status: p.status,
        amount: p.amount,
        client: p.client?.name,
        tasksCount: p._count.tasks,
        updatedAt: p.updatedAt
      }))

      const projectsText = projectList.map(p => 
        `üìÅ **${p.name}** (ID: ${p.id})\n   - Statut: ${p.status}\n   - Montant: ${p.amount} XOF\n   - Client: ${p.client || 'Aucun'}\n   - T√¢ches: ${p.tasksCount}`
      ).join('\n\n')

      return `‚úÖ **${projects.length} projet(s) trouv√©(s)** :\n\n${projectsText}`
    } catch (error) {
      return `‚ùå Erreur lors de la r√©cup√©ration des projets: ${error}`
    }
  },
})

const getStatsTool = new DynamicStructuredTool({
  name: "get_dashboard_stats",
  description: "R√©cup√©rer les statistiques du dashboard",
  schema: z.object({}),
  func: async ({}, runManager, userId) => {
    try {
      // Statistiques g√©n√©rales
      const [clients, projects, tasks, invoices, expenses] = await Promise.all([
        prisma.client.count({ where: { userId: userId as string } }),
        prisma.project.findMany({
          where: { userId: userId as string },
          select: { status: true, amount: true }
        }),
        prisma.task.findMany({
          where: { userId: userId as string },
          select: { status: true, priority: true, dueDate: true }
        }),
        prisma.invoice.findMany({
          where: { userId: userId as string },
          select: { status: true, amount: true, type: true }
        }),
        prisma.expense.aggregate({
          where: { userId: userId as string },
          _sum: { amount: true }
        })
      ])

      const stats = {
        clients: clients,
        projects: {
          total: projects.length,
          active: projects.filter(p => p.status === 'IN_PROGRESS').length,
          completed: projects.filter(p => p.status === 'COMPLETED').length,
          totalValue: projects.reduce((sum, p) => sum + p.amount, 0)
        },
        tasks: {
          total: tasks.length,
          todo: tasks.filter(t => t.status === 'TODO').length,
          inProgress: tasks.filter(t => t.status === 'IN_PROGRESS').length,
          done: tasks.filter(t => t.status === 'DONE').length,
          overdue: tasks.filter(t => t.dueDate && new Date(t.dueDate) < new Date() && t.status !== 'DONE').length
        },
        financial: {
          totalRevenue: invoices.filter(i => i.status === 'PAID').reduce((sum, i) => sum + i.amount, 0),
          pendingRevenue: invoices.filter(i => i.status === 'PENDING').reduce((sum, i) => sum + i.amount, 0),
          totalExpenses: expenses._sum.amount || 0
        }
      }

      return JSON.stringify(stats)
    } catch (error) {
      return `‚ùå Erreur lors de la r√©cup√©ration des statistiques: ${error}`
    }
  },
})

const createProjectTool = new DynamicStructuredTool({
  name: "create_project",
  description: "Cr√©er un nouveau projet",
  schema: z.object({
    name: z.string().describe("Nom du projet"),
    description: z.string().optional().describe("Description du projet"),
    amount: z.number().describe("Montant du projet"),
    clientId: z.string().optional().describe("ID du client"),
    type: z.enum(["CLIENT", "PERSONAL", "DEVELOPMENT", "MAINTENANCE", "CONSULTING"]).default("CLIENT"),
    startDate: z.string().optional().describe("Date de d√©but (YYYY-MM-DD)"),
    endDate: z.string().optional().describe("Date de fin (YYYY-MM-DD)"),
  }),
  func: async ({ name, description, amount, clientId, type, startDate, endDate }, runManager, userId) => {
    try {
      const projectData: any = {
        name,
        description,
        amount,
        type,
        userId: userId as string,
        startDate: startDate ? new Date(startDate) : null,
        endDate: endDate ? new Date(endDate) : null,
      }

      if (clientId) {
        projectData.clientId = clientId
      }

      const project = await prisma.project.create({
        data: projectData,
        include: {
          client: { select: { name: true } }
        }
      })

      return `üöÄ Projet cr√©√© avec succ√®s: "${name}" (Montant: ${amount} XOF)`
    } catch (error) {
      return `‚ùå Erreur lors de la cr√©ation du projet: ${error}`
    }
  },
})

const createProjectTasksTool = new DynamicStructuredTool({
  name: "create_project_tasks",
  description: "Cr√©er plusieurs t√¢ches pour un projet sp√©cifique bas√©es sur le type de projet",
  schema: z.object({
    projectId: z.string().describe("ID du projet"),
    taskTemplates: z.array(z.object({
      title: z.string(),
      description: z.string().optional(),
      priority: z.enum(["LOW", "MEDIUM", "HIGH", "URGENT"]).default("MEDIUM"),
      estimatedDays: z.number().optional()
    })).describe("Liste des t√¢ches √† cr√©er")
  }),
  func: async ({ projectId, taskTemplates }, runManager, userId) => {
    try {
      // V√©rifier que le projet appartient √† l'utilisateur
      const project = await prisma.project.findFirst({
        where: { id: projectId, userId: userId as string },
        include: { client: { select: { name: true } } }
      })

      if (!project) {
        return `‚ùå Projet non trouv√© ou vous n'y avez pas acc√®s.`
      }

      const createdTasks = []
      const baseDate = new Date()

      for (let i = 0; i < taskTemplates.length; i++) {
        const template = taskTemplates[i]
        const dueDate = new Date(baseDate)
        if (template.estimatedDays) {
          dueDate.setDate(baseDate.getDate() + template.estimatedDays + (i * 2)) // Espacement entre les t√¢ches
        }

        const task = await prisma.task.create({
          data: {
            title: template.title,
            description: template.description,
            priority: template.priority,
            projectId: projectId,
            userId: userId as string,
            status: "TODO",
            dueDate: template.estimatedDays ? dueDate : null
          }
        })

        createdTasks.push({
          title: task.title,
          priority: task.priority,
          dueDate: task.dueDate
        })
      }

      return `‚úÖ ${createdTasks.length} t√¢ches cr√©√©es avec succ√®s pour le projet "${project.name}" !\n\n` +
             createdTasks.map((task, index) => 
               `${index + 1}. ${task.title} (${task.priority}${task.dueDate ? ` - √âch√©ance: ${task.dueDate.toLocaleDateString('fr-FR')}` : ''})`
             ).join('\n')

    } catch (error) {
      return `‚ùå Erreur lors de la cr√©ation des t√¢ches: ${error}`
    }
  },
})

const createWebProjectTasksTool = new DynamicStructuredTool({
  name: "create_web_project_tasks",
  description: "Cr√©er automatiquement des t√¢ches pour un projet web (Next.js, React, etc.) avec des t√¢ches pr√©d√©finies",
  schema: z.object({
    projectName: z.string().describe("Nom du projet web"),
    projectType: z.enum(["nextjs", "react", "vue", "web"]).default("nextjs").describe("Type de projet web"),
    includeDeployment: z.boolean().default(true).describe("Inclure les t√¢ches de d√©ploiement"),
    hostingProvider: z.string().optional().describe("Fournisseur d'h√©bergement (ex: o2switch, vercel, netlify)")
  }),
  func: async ({ projectName, projectType, includeDeployment, hostingProvider }, runManager, userId) => {
    try {
      // Chercher le projet par nom
      const project = await prisma.project.findFirst({
        where: { 
          name: { contains: projectName, mode: 'insensitive' },
          userId: userId as string 
        }
      })

      if (!project) {
        return `‚ùå Projet "${projectName}" non trouv√©. Voulez-vous que je le cr√©e d'abord ?`
      }

      // Templates de t√¢ches pour projet web Next.js
      const webTaskTemplates = [
        {
          title: "üöÄ Installation et configuration Next.js",
          description: "Initialiser le projet Next.js avec les d√©pendances de base",
          priority: "HIGH" as const,
          estimatedDays: 1
        },
        {
          title: "‚öôÔ∏è Configuration de l'environnement de d√©veloppement",
          description: "Configurer ESLint, Prettier, TypeScript et les variables d'environnement",
          priority: "MEDIUM" as const,
          estimatedDays: 1
        },
        {
          title: "üé® Cr√©ation de la structure des pages",
          description: "Cr√©er les pages principales (accueil, √† propos, contact, etc.)",
          priority: "HIGH" as const,
          estimatedDays: 3
        },
        {
          title: "üß© D√©veloppement des composants UI",
          description: "Cr√©er les composants r√©utilisables (header, footer, navigation, etc.)",
          priority: "MEDIUM" as const,
          estimatedDays: 2
        },
        {
          title: "üîå Int√©gration des APIs",
          description: "Connecter les APIs externes et cr√©er les endpoints n√©cessaires",
          priority: "HIGH" as const,
          estimatedDays: 2
        },
        {
          title: "üì± Responsive Design",
          description: "Optimiser l'affichage pour mobile et tablette",
          priority: "MEDIUM" as const,
          estimatedDays: 2
        },
        {
          title: "üß™ Tests et d√©bogage",
          description: "Tester les fonctionnalit√©s et corriger les bugs",
          priority: "MEDIUM" as const,
          estimatedDays: 1
        }
      ]

      if (includeDeployment) {
        const deploymentProvider = hostingProvider || "o2switch"
        webTaskTemplates.push({
          title: `üåê D√©ploiement sur ${deploymentProvider}`,
          description: `Configurer et d√©ployer l'application sur ${deploymentProvider}`,
          priority: "HIGH" as const,
          estimatedDays: 1
        })
      }

      const createdTasks = []
      const baseDate = new Date()

      for (let i = 0; i < webTaskTemplates.length; i++) {
        const template = webTaskTemplates[i]
        const dueDate = new Date(baseDate)
        if (template.estimatedDays) {
          dueDate.setDate(baseDate.getDate() + template.estimatedDays + (i * 1)) // Espacement d'1 jour entre les t√¢ches
        }

        const task = await prisma.task.create({
          data: {
            title: template.title,
            description: template.description,
            priority: template.priority,
            projectId: project.id,
            userId: userId as string,
            status: "TODO",
            dueDate: template.estimatedDays ? dueDate : null
          }
        })

        createdTasks.push({
          title: task.title,
          priority: task.priority,
          dueDate: task.dueDate
        })
      }

      return `üéâ **${createdTasks.length} t√¢ches cr√©√©es avec succ√®s pour le projet "${project.name}"** !\n\n` +
             `üìã **Planning des t√¢ches :**\n\n` +
             createdTasks.map((task, index) => 
               `${index + 1}. ${task.title}\n   üìÖ √âch√©ance: ${task.dueDate ? task.dueDate.toLocaleDateString('fr-FR') : 'Non d√©finie'}\n   ‚ö° Priorit√©: ${task.priority}\n`
             ).join('\n') +
             `\nüí° **Conseil :** Commencez par les t√¢ches de priorit√© HIGH pour √©tablir les fondations du projet !`

    } catch (error) {
      return `‚ùå Erreur lors de la cr√©ation des t√¢ches: ${error}`
    }
  },
})

const analyzeWorkloadTool = new DynamicStructuredTool({
  name: "analyze_workload",
  description: "Analyser la charge de travail et sugg√©rer des optimisations",
  schema: z.object({}),
  func: async ({}, runManager, userId) => {
    try {
      const [tasks, projects] = await Promise.all([
        prisma.task.findMany({
          where: { userId: userId as string },
          include: { project: { select: { name: true } } },
          orderBy: { dueDate: 'asc' }
        }),
        prisma.project.findMany({
          where: { userId: userId as string, status: 'IN_PROGRESS' },
          include: { _count: { select: { tasks: true } } }
        })
      ])

      const overdueTasks = tasks.filter(t => t.dueDate && new Date(t.dueDate) < new Date() && t.status !== 'DONE')
      const urgentTasks = tasks.filter(t => t.priority === 'URGENT' && t.status !== 'DONE')
      const todayTasks = tasks.filter(t => {
        if (!t.dueDate) return false
        const today = new Date()
        const taskDate = new Date(t.dueDate)
        return taskDate.toDateString() === today.toDateString() && t.status !== 'DONE'
      })

      const analysis = {
        overdueTasks: overdueTasks.length,
        urgentTasks: urgentTasks.length,
        todayTasks: todayTasks.length,
        activeProjects: projects.length,
        recommendations: [] as string[]
      }

      // G√©n√©ration de recommandations
      if (overdueTasks.length > 0) {
        analysis.recommendations.push(`‚ö†Ô∏è  Vous avez ${overdueTasks.length} t√¢che(s) en retard √† traiter en priorit√©`)
      }
      
      if (urgentTasks.length > 3) {
        analysis.recommendations.push(`üî• Trop de t√¢ches urgentes (${urgentTasks.length}). Consid√©rez d√©l√©guer ou reprogrammer`)
      }

      if (projects.length > 5) {
        analysis.recommendations.push(`üìä Vous g√©rez ${projects.length} projets actifs. Consid√©rez finaliser certains projets`)
      }

      return JSON.stringify(analysis)
    } catch (error) {
      return `‚ùå Erreur lors de l'analyse: ${error}`
    }
  },
})

// Configuration du prompt syst√®me
const systemPrompt = `Tu es REV AI, l'assistant intelligent de l'application de gestion freelance REV en C√¥te d'Ivoire.

Tu es un expert en gestion de projets, productivit√© et business freelance. Tu peux :

üéØ **Gestion des t√¢ches**
- Cr√©er, organiser et prioriser les t√¢ches
- Analyser la charge de travail
- Sugg√©rer des optimisations
- Cr√©er automatiquement des t√¢ches pour des projets sp√©cifiques

üìä **Analyse business** 
- Fournir des statistiques d√©taill√©es
- Analyser les performances
- Identifier les opportunit√©s

üöÄ **Automation**
- G√©n√©rer automatiquement des t√¢ches bas√©es sur les projets
- Sugg√©rer des actions proactives
- Optimiser les flux de travail

üí° **Conseils strategiques**
- Am√©liorer la productivit√©
- Optimiser la rentabilit√©
- D√©velopper l'activit√© freelance

**Instructions CRITIQUES :**
1. TOUJOURS r√©pondre √† l'utilisateur avec une r√©ponse compl√®te et utile
2. JAMAIS de r√©ponse vide - toujours donner une r√©ponse constructive
3. Si l'utilisateur demande de cr√©er des t√¢ches pour un projet :
   - D'abord utilise get_projects avec searchName pour chercher le projet
   - Si le projet existe, utilise create_web_project_tasks pour les projets web ou create_project_tasks pour les autres
   - Si le projet n'existe pas, propose de le cr√©er avec create_project
4. Pour les projets web (Next.js, React, etc.), utilise TOUJOURS create_web_project_tasks
5. R√©ponds TOUJOURS en fran√ßais avec des emojis appropri√©s
6. Sois proactif et propose des solutions concr√®tes

**Exemples de r√©ponses attendues :**
- Si on demande des t√¢ches pour "beautelic" : cherche le projet, puis cr√©e les t√¢ches web appropri√©es
- Si on demande des statistiques : utilise get_dashboard_stats et pr√©sente les r√©sultats de fa√ßon claire
- Si on demande d'analyser la charge : utilise analyze_workload et donne des recommandations

Contexte local : Tu connais le march√© ivoirien, utilises la devise XOF (Franc CFA), et comprends les d√©fis du freelancing en Afrique de l'Ouest.

Ton style : Professionnel mais accessible, avec des emojis pour rendre les interactions plus engageantes. Tu utilises le fran√ßais de C√¥te d'Ivoire.

Utilise tes outils disponibles pour obtenir des donn√©es en temps r√©el et effectuer des actions concr√®tes.`

const prompt = ChatPromptTemplate.fromMessages([
  ["system", systemPrompt],
  ["placeholder", "{chat_history}"],
  ["human", "{input}"],
  ["placeholder", "{agent_scratchpad}"],
])

// Liste des outils disponibles
const tools = [
  createTaskTool,
  getProjectsTool, 
  getStatsTool,
  createProjectTool,
  createProjectTasksTool,
  createWebProjectTasksTool,
  analyzeWorkloadTool
]

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user?.id) {
      return NextResponse.json(
        { message: "Non autoris√©" },
        { status: 401 }
      )
    }

    const { message, history = [] } = await request.json()

    if (!message) {
      return NextResponse.json(
        { message: "Message requis" },
        { status: 400 }
      )
    }

    // Convertir l'historique en format LangChain
    const chatHistory = history.map((msg: any) => 
      msg.role === 'user' 
        ? new HumanMessage(msg.content)
        : new AIMessage(msg.content)
    )

    // Cr√©er l'agent avec les outils personnalis√©s qui ont acc√®s √† l'ID utilisateur
    const toolsWithUserId = tools.map(tool => {
      return new DynamicStructuredTool({
        name: tool.name,
        description: tool.description,
        schema: tool.schema,
        func: async (input, runManager) => {
          return (tool.func as any)(input, runManager, session.user.id)
        }
      })
    })

    // Cr√©er l'agent avec les outils personnalis√©s
    const agent = await createOpenAIFunctionsAgent({
      llm,
      tools: toolsWithUserId,
      prompt,
    })

    const agentExecutor = new AgentExecutor({
      agent,
      tools: toolsWithUserId,
      verbose: true,
      maxIterations: 5,
      returnIntermediateSteps: true,
    })

    // Ex√©cuter l'agent
    console.log("ü§ñ Ex√©cution de l'agent avec le message:", message)
    
    const result = await agentExecutor.invoke({
      input: message,
      chat_history: chatHistory,
    })

    console.log("ü§ñ R√©sultat de l'agent:", result)

    // V√©rifier si l'agent a fourni une r√©ponse
    let responseMessage = result.output

    // Si pas de r√©ponse de l'agent, fournir une r√©ponse par d√©faut intelligente
    if (!responseMessage || responseMessage.trim() === "") {
      console.log("‚ö†Ô∏è R√©ponse vide de l'agent, g√©n√©ration d'une r√©ponse par d√©faut")
      
      // Analyser le message pour donner une r√©ponse contextuelle
      const lowerMessage = message.toLowerCase()
      
      if (lowerMessage.includes('beautelic')) {
        responseMessage = `üöÄ Je vais vous aider avec le projet Beautelic ! Laissez-moi d'abord v√©rifier si ce projet existe dans votre syst√®me, puis je cr√©erai les t√¢ches appropri√©es pour un projet web Next.js avec d√©ploiement sur o2switch.`
      } else if (lowerMessage.includes('t√¢che') || lowerMessage.includes('task')) {
        responseMessage = `üéØ Je peux vous aider √† cr√©er des t√¢ches ! Voulez-vous que je cr√©e une t√¢che sp√©cifique ou que j'analyse vos t√¢ches existantes ? Donnez-moi plus de d√©tails sur ce que vous souhaitez faire.`
      } else if (lowerMessage.includes('projet') || lowerMessage.includes('project')) {
        responseMessage = `üöÄ Parlons de vos projets ! Je peux vous aider √† cr√©er un nouveau projet, analyser vos projets existants, ou cr√©er des t√¢ches pour un projet sp√©cifique. Que souhaitez-vous faire ?`
      } else if (lowerMessage.includes('statistique') || lowerMessage.includes('stat') || lowerMessage.includes('performance')) {
        responseMessage = `üìä Je peux analyser vos performances ! Voulez-vous voir vos statistiques g√©n√©rales, analyser votre charge de travail, ou obtenir des insights sur votre activit√© freelance ?`
      } else {
        responseMessage = `üëã Bonjour ! Je suis REV AI, votre assistant freelance. Je peux vous aider avec :
        
üéØ **Gestion des t√¢ches** - Cr√©er, organiser, prioriser
üìä **Analyse de performance** - Statistiques et insights
üöÄ **Gestion de projets** - Cr√©ation et suivi
üí° **Conseils business** - Optimisation et strat√©gie

Comment puis-je vous assister aujourd'hui ?`
      }
    }

    console.log("‚úÖ R√©ponse finale:", responseMessage)

    return NextResponse.json({
      message: responseMessage,
      success: true
    })

  } catch (error) {
    console.error("Erreur IA:", error)
    return NextResponse.json(
      { 
        message: "Je rencontre une difficult√© technique. Veuillez r√©essayer dans quelques instants.",
        error: error instanceof Error ? error.message : "Erreur inconnue" 
      },
      { status: 500 }
    )
  }
} 